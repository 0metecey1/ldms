
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

static const char *progname = "lua";
/*
 ** Prints an error message, adding the program name in front of it
 ** (if present)
 */
static void l_message (const char *pname, const char *msg) {
    if (pname) luai_writestringerror("%s: ", pname);
    luai_writestringerror("%s\n", msg);
    fflush(stderr);
}

/*
 ** Check whether 'status' is not OK and, if so, prints the error
 ** message on the top of the stack. It assumes that the error object
 ** is a string, as it was either generated by Lua or by 'msghandler'.
 */
static int report (lua_State *L, int status, char *errbuf) {
    if (status != LUA_OK) {
        const char *msg = lua_tostring(L, -1);
        l_message(progname, msg);
        sprintf(errbuf, "%s", msg);
        lua_pop(L, 1);  /* remove message */
    }
    return status;
}

/*
 ** Message handler used to run all chunks
 */
static int msghandler (lua_State *L) {
    const char *msg = lua_tostring(L, 1);
    if (msg == NULL) {  /* is error object not a string? */
        if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
                lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
            return 1;  /* that is the message */
        else
            msg = lua_pushfstring(L, "(error object is a %s value)",
                    luaL_typename(L, 1));
    }
    luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
    return 1;  /* return the traceback */
}

/*
 ** Interface to 'lua_pcall', which sets appropriate message function
 ** and C-signal handler. Used to run all chunks.
 */
static int docall (lua_State *L, int narg, int nres) {
    int status;
    int base = lua_gettop(L) - narg;  /* function index */
    lua_pushcfunction(L, msghandler);  /* push message handler */
    lua_insert(L, base);  /* put it under function and args */
    status = lua_pcall(L, narg, nres, base);
    lua_remove(L, base);  /* remove message handler from the stack */
    return status;
}

static int dochunk (lua_State *L, int status, char *errbuf) {
    if (status == LUA_OK) status = docall(L, 0, 0);
    return report(L, status, errbuf);
}

static int dochunkcoop (lua_State *L, int status, char *errbuf) {
    if (status == LUA_OK) {
        status = docall(L, 0, 0);
    }
    return report(L, status, errbuf);
}

int engine_dofile (lua_State *L, const char *name, char *errbuf) {
    return dochunk(L, luaL_loadfile(L, name), errbuf);
}


int engine_dostring (lua_State *L, const char *s, const char *name, char *errbuf, int concurrent) {
    if (concurrent) {
        // It is assumed that s contains a lua function
        // Wrap this function with 'runProcess(s)' and do the call
        const char *chunkprep = "runProcess(";
        const char *chunkapp = ")";

        /* Wrap 'runProcess()' arround the chunk of Lua code received */
        char *lchunk = (char *)malloc(strlen(s) 
                + strlen(chunkprep) + strlen(chunkapp) + 1);
        strcpy(lchunk, chunkprep);
        strcat(lchunk, s);
        strcat(lchunk, chunkapp);
        return dochunkcoop(L, luaL_loadbuffer(L, lchunk, strlen(lchunk), name), errbuf);
    }
    else
        return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name), errbuf);
}
