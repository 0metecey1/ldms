/*
 * Lua code as a string array to decouple the binary from too many files
 */

const char 
*tracks_wait_support_lua_str = "-- This file implements waitSeconds, waitSignal, signal, and their supporting stuff.\n"
"\n"
"-- This table is indexed by coroutine and simply contains the time at which the coroutine\n"
"-- should be woken up.\n"
"local WAITING_ON_TIME = {}\n"
"\n"
"-- This table is indexed by signal and contains list of coroutines that are waiting\n"
"-- on a given signal\n"
"local WAITING_ON_SIGNAL = {}\n"
"\n"
"-- Keep track of how long the game has been running.\n"
"local CURRENT_TIME = 0\n"
"\n"
"function waitSeconds(seconds)\n"
"    -- Grab a reference to the current running coroutine.\n"
"    local co = coroutine.running()\n"
"\n"
"    -- If co is nil, that means we're on the main process, which isn't a coroutine and can't yield\n"
"    assert(co ~= nil, 'The main thread cannot wait!')\n"
"\n"
"    -- Store the coroutine and its wakeup time in the WAITING_ON_TIME table\n"
"    local wakeupTime = CURRENT_TIME + seconds\n"
"    WAITING_ON_TIME[co] = wakeupTime\n"
"\n"
"    -- And suspend the process\n"
"    return coroutine.yield(co)\n"
"end\n"
"\n"
"function wakeUpWaitingThreads(deltaTime)\n"
"    -- This function should be called once per game logic update with the amount of time\n"
"    -- that has passed since it was last called\n"
"    CURRENT_TIME = CURRENT_TIME + deltaTime\n"
"\n"
"    -- First, grab a list of the threads that need to be woken up. They'll need to be removed\n"
"    -- from the WAITING_ON_TIME table which we don't want to try and do while we're iterating\n"
"    -- through that table, hence the list.\n"
"    local threadsToWake = {}\n"
"    for co, wakeupTime in pairs(WAITING_ON_TIME) do\n"
"        if wakeupTime < CURRENT_TIME then\n"
"            table.insert(threadsToWake, co)\n"
"        end\n"
"    end\n"
"\n"
"    -- Now wake them all up.\n"
"    for _, co in ipairs(threadsToWake) do\n"
"        WAITING_ON_TIME[co] = nil -- Setting a field to nil removes it from the table\n"
"        coroutine.resume(co)\n"
"    end\n"
"end\n"
"\n"
"function waitSignal(signalName)\n"
"    -- Same check as in waitSeconds; the main thread cannot wait\n"
"    local co = coroutine.running()\n"
"    assert(co ~= nil, 'The main thread cannot wait!')\n"
"\n"
"    if WAITING_ON_SIGNAL[signalName] == nil then\n"
"        -- If there wasn't already a list for this signal, start a new one.\n"
"        WAITING_ON_SIGNAL[signalName] = { co }\n"
"    else\n"
"        table.insert(WAITING_ON_SIGNAL[signalName], co)\n"
"    end\n"
"\n"
"    return coroutine.yield()\n"
"end\n"
"\n"
"function signal(signalName)\n"
"    local threads = WAITING_ON_SIGNAL[signalName]\n"
"    if threads == nil then return end\n"
"\n"
"    WAITING_ON_SIGNAL[signalName] = nil\n"
"    for _, co in ipairs(threads) do\n"
"        coroutine.resume(co)\n"
"    end\n"
"end\n"
"\n"
"function runProcess(func)\n"
"    -- This function is just a quick wrapper to start a coroutine.\n"
"    local co = coroutine.create(func)\n"
"    return coroutine.resume(co)\n"
"end\n"
"print('wait_support.lua loaded.')\n"
"";
